\documentclass[11pt]{article}
% Packages used by instructor %
\usepackage{amsmath,amssymb,xspace,epsfig}

% Package for new section on new page
\usepackage{titlesec}

%Package used for formatting lists%
\usepackage[shortlabels]{enumitem}

% Package used for setting up page margins %
\usepackage{geometry}
%\usepackage{showframe} % Used to clearly show the new margins %
\newgeometry{vmargin={1in}, hmargin={1in,1in}}

% Package used for adding hyperlinks %
\usepackage{hyperref}

% Package for multirow tables %
\usepackage{multirow}
\renewcommand{\arraystretch}{1.5}

% Package for displaying algorithms %
\usepackage{algorithm}
\usepackage{algpseudocode}

% Package for Bib in ToC %
\usepackage[nottoc]{tocbibind}

% Break algorithm across pages %
\makeatletter
\newenvironment{breakablealgorithm}
{% \begin{breakablealgorithm}
	\begin{center}
		\refstepcounter{algorithm}% New algorithm
		\hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
		\renewcommand{\caption}[2][\relax]{% Make a new \caption
			{\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
			\ifx\relax##1\relax % #1 is \relax
			\addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
			\else % #1 is not \relax
			\addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
			\fi
			\kern2pt\hrule\kern2pt
		}
	}{% \end{breakablealgorithm}
		\kern2pt\hrule\relax% \@fs@post for \@fs@ruled
	\end{center}
}
\makeatother

% Page Header %
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{Ananlysis of Algorithms \\ Home Work 3}
\rhead{Narayan Acharya \\ 112734365}
\lfoot{\leftmark}
\rfoot{\thepage}

% Do not indent pargraphs everywhere %
\setlength\parindent{0pt}

\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

\title{
	Analysis of Algorithms - Home Work 3\\[2mm]
	\large CSE 548 Fall '19\\[1mm]
	\href{mailto:jgao@cs.stonybrook.edu}{\textit{Prof. Jie Gao}}
}
\author{
	\small Submission By: \\
	\href{mailto:nacharya@cs.stonybrook.edu}{Narayan Acharya} \\
	\small 112734365
}
\date{\vspace{-5ex}}
\begin{document}

% Set up title
\maketitle
\thispagestyle{fancy} % Make this page use fancy header

% Set up Table of Contents
\tableofcontents

\clearpage

\section{Question 1} Textbook [Kleinberg \& Tardos] Chapter 4, page 190, problem \#6. \\
\textbf{Solution:} \\

Let us say that the $ i^{th} $ contestant has a swimming, biking and running time denoted by $ s_i $, $ b_i $ and $ r_i $ respectively. We are to order the contestants such that the last contestant to finish has the earliest possible finishing time. We also have a constraint that no 2 contestants can have overlapping swimming times. Although, there is NO such constraint on their biking and running times. Let us consider the biking and running time of $ i^{th} $ contestant to be $ p_i $ where $ p_i = b_i + r_i $. \\

Consider the following way of ordering the contestants to achieve our goal: We order them in decreasing order of $ p_i $. That is, for contestants $ i $ and $ j $, if $ i $ has a higher $ p_i $ then he/she goes before $ p_j $. We can argue that this is the most optimal way of ordering contestants by considering existence of another solution that does not follow above rule and is optimal. \\

Consider that there exists an optimal solution different from the one proposed above such that for contestants $ i $ and $ j $, where $ i $ starts before $ j $ and $ p_i < p_j $. Given that i start before j, i will leave the pool earlier and. Time to complete the race from when $ i $ started: 
\begin{equation*}
	t_{i1} = s_i + p_i
\end{equation*}
\begin{equation*}
	t_{j1} = s_i + s_j + p_j
\end{equation*}
Comparing the two, we can easily see that $ i $ will finish earlier (strike our $ s_i $ from both, $ p_i < p_j $ and $ s_j > 0 $). Thus, $ t_{i1} < t_{j1} $\\

Let us swap i and j now and compare the times to complete from when $ j $ started:
\begin{equation*}
t_{j2} = s_j + p_j
\end{equation*}
\begin{equation*}
t_{i2} = s_j + s_i + p_i
\end{equation*}
Comparing these with $t_{i1} $ and $ t_{j1} $, we can easily see that:
\begin{equation*}
t_{i1} < t_{j2} < t_{j1}
\end{equation*}
\begin{equation*}
t_{i1} < t_{i2} < t_{j1}
\end{equation*}

In all cases $ t_{j1} $ is highest. That means our approach with the first option is not as good compared to our second options where we switched contestants and brought them in accordance of our proposed solution. Hence, it is better if we swap i and j.

\clearpage
\section{Question 2} Textbook [Kleinberg \& Tardos] Chapter 4, page 190, problem \#12. \\
\textbf{Solution:} \\
\begin{enumerate}[(a)]
\item Our constraint is such that any time $ t $, the total number of bits we've sent through from time 0 to $ t $ cannot exceed $ rt $. The constraint does NOT bound number of bits we can send at any specific time $ t $. So, at any time we can send more bits than the rate specified, if we've sent lesser bits in the previous stream.

So the constraint, $ b_i < rt_i $ only holds for the first stream of bits. Subsequent streams may or may not hold to this inequality. In either case they will still be valid. So the claim is false.

\item We can use the 'Greedy Algorithm Stays Ahead' argument to prove our case. In order to find a valid and feasible schedule we sort by bits we need to transmit in each stream i.e. We sort by $ b_i/t_i $. In such an ordering we always transmit the least number of bits we can possibly send at that time. If at any time, our constraint does not hold true then there is no way we can send another stream of bits ahead of this as it will at least transmit as many bits as the current stream because we have sorted them in increasing order of bit-rate. The running time of this algorithm will be bound by $ O(nlogn) $, the amount of time we need to sort the streams in increasing order of bit-rate.

To only find whether there exists a schedule where we can order all streams without breaking the constraint we simply keep of track of number of bits 'saved' at each transmission. Bits saved can be used to transmit another stream having a higher bit-rate than the allowed maximum rate of $ r $. In these cases, we can consider the bits saved to be negative. If the total sum of all such bits saved is greater than 0, then we can claim that we can order streams in some order without breaking the constraint. The running time for this will be $ O(n) $ as we only need to calculate bits saved at each bit-stream and keep track of total bits saved.
\end{enumerate}


\clearpage
\section{Question 3} Textbook [Kleinberg \& Tardos] Chapter 4, page 190, problem \#14. \\
\textbf{Solution:} \\

\begin{enumerate}[(a)]
\item We wish to minimize the number of times we invoke the script to check our critical processes. The greedy approach to this would be holding off on the check as long as possible and doing one if absolutely necessary so that we don't miss a process. One approach would be to sort the processes according to their finish times and to invoke the status check right before the process finishes if the process has not been checked at least once prior. Let us consider the correctness and optimality of our approach.
\begin{enumerate}[(1)]
\item Correctness: The approach ensures that all the processes are checked because we invoke the status check right before the end time of every process if it has not yet been checked. Thus it computes a valid set of status check invocation timings.

\item Optimality: To argue that this approach computes the minimum number of status checks we use 'Greedy Algorithm Stays Ahead' argument. Consider, that our algorithm produces $ k $ status checks up to a certain process evaluation, and the set is denoted by $ S $. Also, there exists another set of optimal status checks, $ S' $. We would like to show that $ S' $ too has at least $ k $ status checks up until the same process is evaluated. We prove this by induction:
\begin{enumerate}
	\item For $ n=1 $, both S and S' will have to have at least 1 status check.
	\item For some $ n=m $, say $ S $ and $ S' $ have $ k $ status checks. 
	\item For $ n=m+1 $, we have two options, $ (m+1)^{th} $ overlaps or does not overlap with our current process. In case it does, our $ k^{th} $ status check in S will take care of the status check for $ (m+1)^{th} $ process. In case it does not, we will need to add our $ (k+1)^{th} $ status check at the finish time of the $ (m+1)^{th} $ process. In both cases, $ S' $ too will need to add at least one more check to cover the $ (m+1)^{th} $ process. Thus we have $ (k+1) $ checks for in both $ S $ and $ S' $.
\end{enumerate}
Thus our algorithm will perform at least as well any other optimal algorithm. The algorithm is bound by $ O(nlogn) $ - the amount it would required to sort the processes by their finishing times and $ O(n) $ - the amount of time to iterate over the sorted processes to insert the process checks. Thus, running time is bound by $ O(nlogn) $.

\end{enumerate}

\item 
\end{enumerate}

\clearpage
\section{Question 4} Textbook [Kleinberg \& Tardos] Chapter 4, page 190, problem \#16. \\
\textbf{Solution:} \\

\clearpage
\section{Question 5} Textbook [Kleinberg \& Tardos] Chapter 5, page 246, problem \#1. \\
\textbf{Solution:} \\

\clearpage
\section{Question 6} Textbook [Kleinberg \& Tardos] Chapter 5, page 246, problem \#7. \\
\textbf{Solution:} \\

\clearpage
\bibliographystyle{unsrt}
\begin{thebibliography}{9}
	\bibitem{} 
	,
	\\\texttt{}
	
\end{thebibliography}

\end{document}